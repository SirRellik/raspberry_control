from __future__ import annotations
from datetime import date, timedelta
import httpx
import time
import os
import asyncio
import json
from fastapi import FastAPI, Body
from fastapi.middleware.cors import CORSMiddleware
from settings import SES_PRICE_URL
from logic.shelly import boiler_set
from logic.mqttbus import MQTTBus

app = FastAPI(title="SES Control", version="0.2")

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_methods=["*"],
    allow_headers=["*"],
)

# Konfigurace Shelly zařízení
SHELLY_CONFIG = {
    "pata_domu": {
        "ip": "192.168.1.94",
        "name": "Pata domu - hlavní měření",
        "type": "3em",
        "communication": "rpc"
    },
    "fve_mereni": {
        "ip": "192.168.1.6", 
        "name": "FVE - výroba",
        "type": "3em",
        "communication": "rpc"
    },
    "shelly_1pm": {
        "ip": "192.168.1.98",
        "name": "Shelly 1PM",
        "type": "1pm", 
        "communication": "mqtt"
    },
    "shelly_pro2": {
        "ip": "192.168.1.153",
        "name": "Shelly Pro2",
        "type": "pro2",
        "communication": "mqtt"
    }
}

# Globální proměnné
power_data = {
    "grid": 0,
    "pv": 0,
    "consumption": 0,
    "timestamp": time.time()
}

devices_data = {}
current_prices = []
mqtt_client = None
mqtt_topics = []

# RPC komunikace modul
class ShellyRPC:
    @staticmethod
    async def get_em_status(ip: str, em_id: int = 0):
        try:
            async with httpx.AsyncClient(timeout=5.0) as client:
                response = await client.get(f"http://{ip}/rpc/EM.GetStatus?id={em_id}")
                if response.status_code == 200:
                    return response.json()
        except Exception as e:
            print(f"RPC error {ip}: {e}")
        return None

# Fetch dat ze všech zařízení
async def update_all_devices():
    global power_data, devices_data
    
    current_time = time.time()
    
    # Pata domu (hlavní měření) - RPC
    pata_data = await ShellyRPC.get_em_status(SHELLY_CONFIG["pata_domu"]["ip"])
    if pata_data:
        total_power = pata_data.get("total_act_power", 0)
        devices_data["pata_domu"] = {
            "power": abs(total_power),
            "total_power": total_power,
            "status": "online",
            "timestamp": current_time,
            "phases": {
                "a": pata_data.get("a_act_power", 0),
                "b": pata_data.get("b_act_power", 0), 
                "c": pata_data.get("c_act_power", 0)
            }
        }
        print(f"Pata domu: {total_power}W")
    else:
        devices_data["pata_domu"] = {"power": 0, "status": "offline", "timestamp": current_time}
    
    # FVE měření - RPC
    fve_data = await ShellyRPC.get_em_status(SHELLY_CONFIG["fve_mereni"]["ip"])
    if fve_data:
        fve_power = fve_data.get("total_act_power", 0)
        devices_data["fve_mereni"] = {
            "power": abs(fve_power),
            "total_power": fve_power, 
            "status": "online",
            "timestamp": current_time,
            "phases": {
                "a": fve_data.get("a_act_power", 0),
                "b": fve_data.get("b_act_power", 0),
                "c": fve_data.get("c_act_power", 0)
            }
        }
        print(f"FVE: {fve_power}W")
    else:
        devices_data["fve_mereni"] = {"power": 0, "status": "offline", "timestamp": current_time}
    
    # Vypočítat celkové hodnoty
    pata_power = devices_data.get("pata_domu", {}).get("total_power", 0)
    fve_power = devices_data.get("fve_mereni", {}).get("total_power", 0)
    
    pv_production = abs(fve_power) if fve_power < 0 else 0
    grid_flow = pata_power
    house_consumption = pv_production + max(0, grid_flow)
    
    power_data = {
        "grid": grid_flow / 1000,
        "pv": pv_production / 1000,
        "consumption": house_consumption / 1000,
        "timestamp": current_time
    }

async def start_device_polling():
    while True:
        try:
            await update_all_devices()
        except Exception as e:
            print(f"Device polling error: {e}")
        await asyncio.sleep(5)

@app.get("/health")
async def health():
    return {"ok": True, "version": "0.2", "devices": len(devices_data)}

@app.get("/api/prices/today")
async def prices_today():
    url = SES_PRICE_URL.format(date=date.today().isoformat())
    async with httpx.AsyncClient(timeout=15.0) as client:
        r = await client.get(url)
        r.raise_for_status()
        data = r.json()
        global current_prices
        current_prices = data.get("data", [])
        return data

@app.get("/api/prices/yesterday")
async def prices_yesterday():
    yesterday = date.today() - timedelta(days=1)
    url = SES_PRICE_URL.format(date=yesterday.isoformat())
    async with httpx.AsyncClient(timeout=15.0) as client:
        r = await client.get(url)
        r.raise_for_status()
        return r.json()

@app.get("/api/power/current")
async def get_current_power():
    return power_data

@app.get("/api/devices/all")
async def get_all_devices():
    return {
        "devices": devices_data,
        "config": SHELLY_CONFIG,
        "last_update": max([d.get("timestamp", 0) for d in devices_data.values()] or [0])
    }

@app.get("/api/dashboard/data")
async def get_dashboard_data():
    current_hour = int(time.strftime("%H"))
    current_price = 85.0
    if current_prices:
        price_entry = next((p for p in current_prices if p.get("hour") == current_hour), None)
        current_price = price_entry.get("price_eur", current_price) if price_entry else current_price
    
    return {
        "power": power_data,
        "devices": {
            "pata_domu": {
                "power": devices_data.get("pata_domu", {}).get("power", 0),
                "status": devices_data.get("pata_domu", {}).get("status", "offline"),
                "name": SHELLY_CONFIG["pata_domu"]["name"],
                "ip": SHELLY_CONFIG["pata_domu"]["ip"]
            },
            "fve_mereni": {
                "power": devices_data.get("fve_mereni", {}).get("power", 0),
                "status": devices_data.get("fve_mereni", {}).get("status", "offline"),
                "name": SHELLY_CONFIG["fve_mereni"]["name"],
                "ip": SHELLY_CONFIG["fve_mereni"]["ip"]
            },
            "grid_power": {
                "power": abs(power_data.get("grid", 0) * 1000),
                "flow": "dodávka" if power_data.get("grid", 0) < 0 else "odběr",
                "status": "online" if power_data.get("timestamp", 0) > time.time() - 30 else "offline",
                "name": "Síť (vypočteno)"
            },
            "house_consumption": {
                "power": power_data.get("consumption", 0) * 1000,
                "status": "online",
                "name": "Spotřeba domu"
            }
        },
        "prices": {
            "current": current_price,
            "hourly": current_prices
        },
        "system": {
            "rpc_connected": len(devices_data) > 0,
            "mqtt_connected": mqtt_client is not None,
            "devices_online": sum(1 for d in devices_data.values() if d.get("status") == "online")
        },
        "timestamp": time.time()
    }

@app.post("/api/boiler")
async def api_boiler(payload: dict = Body(...)):
    on = bool(payload.get("on"))
    return await boiler_set(on)

@app.on_event("startup")
async def startup_event():
    print("Starting SES Control Backend v0.2")
    asyncio.create_task(start_device_polling())
    print("RPC device polling started (every 5s)")
    
    mqtt_url = os.getenv("MQTT_URL", "")
    if mqtt_url:
        try:
            global mqtt_client
            mqtt_client = MQTTBus(mqtt_url, "ses-backend")
            print(f"MQTT connected to {mqtt_url}")
        except Exception as e:
            print(f"MQTT setup failed: {e}")
    
    print("Backend startup complete")

@app.on_event("shutdown") 
async def shutdown_event():
    print("Shutting down SES Control Backend")
